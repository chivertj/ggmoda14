#ifndef GGREGIONTRACKER
#define GGREGIONTRACKER

#include "ggtracker.h"
#include "ggsimcorr.h"
#include "ggregiontrack.h"
#include "ggpropagating.h"
#include "ggtracks.h"
#include "ggframe.h"

namespace gg {
  /**
   * tracks binary regions only \n
   * gg::frame data not stored (past 1 time history with gg::regiontracker::cframe and gg::regiontracker::pframe) \n
   * gg::frame data stored by container of gg::regiontracker \n 
   * which is gg::timewindow::frames\n
   */
  class regiontracker {
  public:
    typedef objecttrackproperties TRACK_T;
    typedef objtracks<TRACK_T> OBJTRACKS_T;
  protected:
    frame pframe;
    frame cframe;
    OBJTRACKS_T ctrackers,ptrackers,goodtracks;
    trackpropagateconstraints constraints;
    bool finalised;
  public:
    regiontracker(const frameproperties &props) :
      pframe(props), cframe(props), ctrackers(_MAXNREGIONS),ptrackers(_MAXNREGIONS),goodtracks(0), finalised(false) {
      cv::Mat_<float> minconstraints(0,0),maxconstraints(2,1);
      maxconstraints(0,0)=props.X;
      maxconstraints(1,0)=props.Y;

      constraints(minconstraints,maxconstraints,0,0);
    }
    void predict(void) {
      for (size_t i=0;i<cframe.size();i++) 
	ctrackers[i].predict();
    }
    void correct(const frame &_cframe, const regioncorrespondences corrs) {
      if (finalised)
	throw gg::error("ggregiontrackerL44");
      //      std::cout <<"Correcting..."<<std::endl;
      pframe=cframe;
      cframe=_cframe;
      std::cout <<"cframe time:"<<cframe.gettime()<<std::endl;
      ptrackers=ctrackers;
      int previdx;
      cv::Mat_<float> m(5,1);
      std::cout <<"***Active track count:"<<cframe.size()<<" ***"<<std::endl;
      for (size_t i=0;i<cframe.size();i++) {
	m(0,0)=cframe[i].getregprops().getcog().x;
	m(1,0)=cframe[i].getregprops().getcog().y;
	m(2,0)=cframe[i].getregprops().getboundbox().size.width;
	m(3,0)=cframe[i].getregprops().getboundbox().size.height;
	m(4,0)=cframe[i].getregprops().getboundbox().angle;

	previdx=corrs.getcurr2prev()[i];

	if (previdx!=-1) {
	  ptrackers[previdx].correct(m,cframe.gettime(),cframe[i]);
	  ctrackers[i]=ptrackers[previdx];
	}
	else
	  ctrackers[i].initkalman(m);
	std::cout <<"Track "<<i<<" length "<<ctrackers[i].count()<<" frameno:"<<ctrackers[i].getmaxframeno()<<std::endl;
      }
      for (size_t i=0;i<pframe.size();i++) {
	int curridx=corrs.getprev2curr()[i];
	if (curridx==-1) {
	  if (ptrackers[i].count()>20) 
	    goodtracks.push_back_merge(constraints,ptrackers[i]);
	}
      }
      //      std::cout <<"FINISHED CORRECT in gg::regiontracker"<<std::endl;
    }
    /// Only call this function when no more frames are to be added.
    void finalise(void) {
      for (size_t i=0;i<cframe.size();i++) {
	if (ctrackers[i].count()>20)
	  goodtracks.push_back_merge(constraints,ctrackers[i]);
      }
      finalised=true;
    }
    const OBJTRACKS_T& getgoodtracks(void) const { return goodtracks; }
    OBJTRACKS_T& getgoodtracks(void) { return goodtracks; }
  };
}

#endif //GGREGIONTRACKER

